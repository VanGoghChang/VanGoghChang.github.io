---
layout: post
title: Swift 基础（笔记一）
---

## 前言
Swift 是一门开发 iOS, macOS, watchOS 和 tvOS 应用的新语言。它包含
了 C 和 Objective-C 上所有基础数据类型，Int表示整型值；
Double 和 Float 表示浮点型值； Bool 是布尔型值；String 是文本型数
据。 Swift 还提供了三个基本的集合类型，Array ，Set 和 Dictionary。
 
Swift 增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。
元组可以让你创建或者传递一组数据。
 
Swift 增加了可选（Optional）类型，用于处理值缺失的情况。
 
### 常量和变量
 
常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。

![](/images/19_12_05/Swift1_1.png)

常量的值一旦设定就不能改变，而变量的值可以随意更改。

当你声明常量或者变量的时候可以加上类型标注（type annotation），说明
常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量
名后面加上一个冒号和空格，然后加上类型名称。

![](/images/19_12_05/Swift1_2.png)

注意：如果你在声明常量或者变量的时候赋了一个初始值，此时你没有蟹类型标注，
Swift 也可以推断出这个常量或者变量的类型。

### 类型别名

类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用 typealias 关
键字来定义类型别名。

当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度
的外部资源的数据。定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名，如：

![](/images/19_12_05/Swift1_6.png)


### 数值型字面量

整数字面量可以被写作：

一个十进制数，没有前缀
一个二进制数，前缀是0b
一个八进制数，前缀是0o
一个十六进制数，前缀是0x

下面的所有整数字面量的十进制值都是17:

![](/images/19_12_05/Swift1_4.png)

十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 e 来指定；
十六进制浮点数必须有一个指数，通过大写或者小写的 p 来指定。

如果一个十进制数的指数为 exp，那这个数相当于基数和10^exp的乘积：

1.25e2 表示 1.25 × 10^2，等于 125.0。
1.25e-2 表示 1.25 × 10^-2，等于 0.0125。

如果一个十六进制数的指数为exp，那这个数相当于基数和2^exp的乘积：

0xFp2 表示 15 × 2^2，等于 60.0。
0xFp-2 表示 15 × 2^-2，等于 3.75。

数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：

let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1



### 整数

整数就是没有小数部分的数字，比如 42 和 -23 。整数可以是 有符号（正、负、零）
或者 无符号（正、零）。

可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值：
 
![](/images/19_12_05/Swift1_3.png) 

#### Int（有符号整数）

一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型 Int，长度
与当前平台的原生字长相同：

在32位平台上，Int 和 Int32 长度相同。
在64位平台上，Int 和 Int64 长度相同。

除非你需要特定长度的整数，一般来说使用 Int 就够了。

#### UInt（无符号整数）

Swift 也提供了一个特殊的无符号类型 UInt，长度与当前平台的原生字长相同：

在32位平台上，UInt 和 UInt32 长度相同。
在64位平台上，UInt 和 UInt64 长度相同。

注意：尽量不要使用UInt，除非你真的需要存储一个和当前平台原生字长相同的无符
号整数。除了这种情况，最好使用Int，即使你要存储的值已知是非负的。统一使
用 Int 可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的
类型推断。

### 浮点数

浮点数是有小数部分的数字，比如 3.14159 ，0.1 和 -273.15。浮点类型比整数类
型表示的范围更大，可以存储比 Int 类型更大或者更小的数字。Swift 提供了两种有
符号浮点数类型：

Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型，至少15位。
Float表示32位浮点数。精度要求不高的话可以使用此类型，6位。

### 数值型类型转换

#### 整数转换

不同整数类型的变量和常量可以存储不同范围的数字。Int8类型的常量或者变量可以存储的数字
范围是-128~127，而UInt8类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常
量或者变量可存储的范围，编译的时候会报错。

要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型
就是你的目标类型。例如：

![](/images/19_12_05/Swift1_5.png)

目标常量 twoThousandAndOne 的类型被推断为 UInt16，因为它是两个 UInt16 值的和。

#### 整数和浮点数转换

整数和浮点数的转换原理与不同整数之间类型转换相同。

注意：
结合数字类常量和变量不同于结合数字类字面量。字面量3可以直接和字面量0.14159相加，因为
数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。

### 布尔值
基本的布尔（Boolean）类型，叫做Bool。布尔值指逻辑上的值，因为它们只能是真或者假。
Swift 有两个布尔常量，true 和 false。

### 元组

元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。

举例：

![](/images/19_12_05/Swift1_7.png)

在上面创建的元组中就包含了三种类型 ( String, Int, Bool, String )。

你可以将一个元组的内容分解成单独的常量和变量，然后你就可以正常使用它们，
如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记，如：

![](/images/19_12_05/Swift1_8.png)

也可直接通过下标访问，如：

![](/images/19_12_05/Swift1_9.png)

也可以在定义元组的时候给单个元素命名，通过名字访问：

![](/images/19_12_05/Swift1_10.png)

注意：
元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时
使用，请使用类或者结构体而不是元组。

### 可选类型

可选类型（optionals）来处理值可能缺失的情况。可选类型表示：

有值，等于 x， 或者 没有值

例如，Swift 中 Int 类型的构造器，将一个其他类型（如 String）的值转换成一个 Int 值。但是
不是所有的字符串都可以转换成一个整数。比如字符串 "123" 可以转换成整数 123，但字符串 "Hello" 不行。

![](/images/19_12_05/Swift1_11.png)

上述可知 Int 构造器有可能会失败，所以它返回的是一个可选类型（optional）Int，不是一个 Int。可选类
型 Int 写作 Int?。代表可能包含 Int 值，也可能什么值也不包含。

#### nil

可以给可选变量赋值为 nil 来表示它没有值，但是 nil 不能用于非可选的常量与变量赋值。如果声明
一个可选常量或变量但是没有赋值，会默认设置成 nil。

注意：
Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存
在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选
状态都可以被设置为 nil，不只是对象类型。

#### 强制解析

当确定可选类型确实包含值之后，可在可选常量或变量的后面加一个感叹号（!）来获取值，这被为可选值
的强制解析。

![](/images/19_12_05/Swift1_12.png)

#### 可选绑定

使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者
变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可
以将可选类型中的值赋给一个常量或者变量。

![](/images/19_12_05/Swift1_13.png)

#### 隐式解析可选类型

可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。

有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。

这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。

一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。

注意：如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。

### 错误处理

你可以使用 错误处理（error handling） 来应对程序执行中可能会遇到的错误条件。

这里有一个错误处理如何用来应对不同错误条件的例子。

![](/images/19_12_05/Swift1_14.png)

相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。

当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。

一个函数可以通过在声明中添加throws关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置try关键词。

一个do语句创建了一个新的包含作用域,使得错误能被传播到一个或多个catch从句。

在此例中，makeASandwich()（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为 makeASandwich() 抛出错误，函数调用被包裹在 try 表达式中。将函数包裹在一个 do 语句中，任何被抛出的错误会被传播到提供的 catch 从句中。

如果没有错误被抛出，eatASandwich() 函数会被调用。如果一个匹配 SandwichError.outOfCleanDishes 的错误被抛出，washDishes() 函数会被调用。如果一个匹配 SandwichError.missingIngredients 的错误被抛出，buyGroceries(_:) 函数会被调用，并且使用 catch 所捕捉到的关联值 [String] 作为参数。






